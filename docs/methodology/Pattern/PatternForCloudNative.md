# 云原生介绍

## 认识云原生

> CNCF对云原生定义
>
> 云原生技术使组织能够在现代动态环境（例如公共云、私有云和混合云）中构建和运行可扩展的应用程序。容器、服务网格、微服务、不可变基础设施和声明式 API 是这种方法的例证。这些技术使松散耦合的系统具有弹性、可管理性和可观察性。结合强大的自动化，它们使工程师能够以最少的劳动频繁地、可预测地进行高影响力的更改。

通过云原生应用生命周期的每个阶段, 全面了解云原生的所有特征, 对所有特征做以下定义:

​	*云原生正在将软件应用程序构建为一组独立的、松散耦合的、面向业务能力的服务（微服务），这些服务可以在动态环境（公共、私有、混合、多云）中以自动化、可扩展、有弹性、可管理和可观察的方式。*



使用服务以微服务的形式呈现, 那么什么是微服务呢? 除了微服务还有些什么架构? ---- 请参见更多服务架构

云原生应用除了在开发的时候重要, 在部署发布的时候也很重要. 云原生使用容器化进行部署发布, 如何管理容器的执行和容器的生命周期, 这个就是容器编排的作用.

**为什么要进行容器编排？**

容器编排是容器的生命周期管理. 在真实项目中使用手动管理容器几乎是不可能的. 因此容器编排是云原生架构的重要组成部分, 容器编排具有的一些特征和功能:

*自动配置*

​	自动供应容器实例和部署容器

*高可用性*

​	当一个容器运行时失败时自动重新配置容器

*缩放*

​	根据需求，自动添加或删除容器实例，实现应用的扩容或缩容

*资源管理*

​	在容器之间分配资源

*服务接口和负载均衡*

​	将容器暴露给外部系统并管理进入容器的负载

*网络基础设施抽象*

​	提供网络覆盖以在容器之间建立通信

*服务发现*

​	提供使用服务名称发现服务的内置功能

*控制平面*

​	提供单一位置来管理和监控容器化系统

*亲和力*

​	提供彼此靠近或远离的容器，以提高可用性和性能

*健康监测*

​	自动检测故障并提供自我修复

*滚动升级*

​	以零停机时间协调增量升级

*组件化和隔离*

​	通过使用命名空间等概念在各种应用程序域之间引入逻辑分离

如上的那些功能, 都是容器编排需要具备的能力. 现在Kubernetes已经成为容器编排的标准. 以上真是对运维满满的恶意, 开发啥都不管了.

**自动化开发生命周期**

在谈到云原生时, 交付, 敏捷, 安全很重要. 因此云原生开发过程中, 每一个步骤的自动化是必须要达成的目标. 包括测试, 构建, 发布, 配置, 基础设置管理, CI/CD等. 下图展示云原生的所有阶段:

![image-20220105160240797](PatternForCloudNative.assets/image-20220105160240797.png)

**动态管理**

云原生应用部署到生产环境中, 并不是一层不变的, 需要对应用进行观察和管理. 下列展示了可能具备的观察和管理功能:

*自动缩放*

​	根据流量或负载扩展或缩减应用程序实例

*高可用性*

​	在发生故障时，提供在当前数据中心生成新实例或将流量转移到不同数据中心的能力

*资源优化*

​	确保资源的最佳使用，动态扩展，没有前期成本，但实时自动响应扩展需求

*可观察性*

​	通过中央控制启用云原生应用程序的日志、指标和跟踪

*服务质量 (QoS)*

​	支持跨应用程序的端到端安全性、节流、合规性和版本控制

*中控平面*

​	提供一个中央位置来管理云原生应用程序的各个方面

*资源配置*

​	管理每个应用程序的资源分配（CPU、内存、存储、网络）

*多云支持*

​	提供跨多个云环境管理和运行应用程序的能力，包括私有云、混合云和公共云（因为给定的应用程序可能需要来自多个云提供商的组件和服务）

## 构建云原生应用的方法论

同样, 任何一种架构都需要方法论, 云原生同样如此. 该方法论并不完全跟以往传统方法论一样. 

有些人认为是使用[The Twelve-Factor](https://12factor.net/), 但是还有一定的差距; 12factor并未覆盖应用开发周期的方方面面.  

因此我们需要一种更完整, 更实用的方法来构建云原生应用. 次方法论分为几个阶段如下图:

![image-20220105161211022](PatternForCloudNative.assets/image-20220105161211022.png)

下面对每个阶段进行简单的解读:

### 设计应用程序

正在构建一个包含微服务的云原生应用程序时候，不能立即进入应用程序开发。需要围绕您想要迎合的业务来设计应用程序。这需要清楚地识别应用程序必须提供的业务能力以及应用程序需要使用的外部依赖项（服务或系统）。

因此，在设计阶段，应该仔细查看业务用例并确定要构建的微服务。云原生应用的设计可以使用领域驱动设计 (DDD) 方法论，在复杂业务上建立抽象逻辑并在软件组件中表示它们。

DDD 过程从分析业务领域（例如，零售或医疗保健）并在该领域内定义应用特定领域模型的边界开始。这些被称为*有界上下文.* 例如，组织可能具有有限的上下文，例如销售、人力资源 (HR)、支持等。每个有界上下文可以进一步分解为*聚合*，可以被视为单个单元的域对象集群。

这些有界上下文可能会也可能不会直接映射到微服务。当我们设计云原生应用程序时，通常我们可以从每个有界上下文的服务开始，然后将其分解为围绕聚合构建的更小的服务。云原生应用的 DDD 完成后，您还可以在识别微服务的同时确定服务接口/定义和通信风格。

### 开发应用程序

在开发中阶段，我们根据在设计阶段确定的业务用例和服务接口构建应用程序。

### 独立代码库

云原生应用的每个微服务都应该有一个*代码库*在版本控制系统上进行跟踪。服务的多个实例，称为*部署*。因此，你可以将服务部署到不同的环境中，例如开发、测试和生产——所有环境都使用相同的代码库（但它们可能使用不同版本的代码库）。

### 显式依赖

全部微服务的代码级依赖项必须明确声明并相互隔离。依赖项应该在作为微服务代码一部分的清单中声明，并且服务不应该依赖于任何未明确声明的系统范围的依赖项。

### 解耦配置

作为我们之前讨论过，云原生应用程序包含部署到多个环境中的服务的单个代码库。这只有在微服务的配置与微服务代码完全解耦的情况下才有可能。服务的代码库与环境无关，并且配置因部署而异。

### 独立测试

一个微服务应该有独立的测试来独立验证其功能。通常，这些测试是微服务开发周期的一个组成部分，微服务的验证发生在构建和部署阶段。我们可以考虑这些*单元测试* 因为它们被本地化到给定微服务的范围内。

但是，由于云原生应用程序包含多个协同工作以服务于特定业务用例的微服务，因此仅靠单元测试无法测试应用程序的整体功能。我们还需要系统范围的测试，称为*集成测试*. 这些测试将微服务和其他系统收集在一起，并将它们作为一个单元进行测试，以验证它们是否按预期协作，以实现更大的业务能力。另外除了功能性测试以外, 稳定性测试, 性能测试, 故障测试也是必不可少的步骤。

### 容器化

虽然容器化不是构建云原生应用程序的强制性要求，但它在实现其大部分特性和要求方面非常有用。

将云原生应用程序封装到一个包含所有依赖项、运行时和配置的包中是通过容器化实现的。容器化（使用 Docker 等技术）使微服务*不可变*，这意味着它们可以立即启动或停止，并丢弃任何有问题的实例，而不是修复或升级。这要求我们容器化的微服务具有快速启动时间和正常关闭时间。因此，当您利用容器原生框架和技术时，容器化效果最好。（如果由于我们容器化的应用程序的固有限制而无法实现快速启动，Kubernetes 等容器编排系统会提供就绪和活跃度检查，以确保应用程序已准备好为其消费者服务。）

### 连接性、组合和 API

作为我们在本章开头讨论过，云原生应用程序是通过网络通信连接的分布式应用程序。当我们将它们设计为一组微服务时，我们经常需要在这些服务和外部系统之间进行交互。因此，在服务之间建立连接并正确定义 API 和服务接口至关重要。

### 服务主导的互动

全部微服务和应用程序应将其功能作为*服务*公开。同样，微服务消耗的任何外部能力和资源也应声明为服务（通常称为*后备服务）*）。

服务的概念是一种抽象这在很多方面有助于微服务交互。服务是动态服务发现的推动者，保持服务元数据的存储库/注册表。它还允许您实现负载平衡等概念。这就是为什么将服务抽象作为一流抽象构建到容器编排平台中的原因。因此，当您使用一组微服务构建云原生应用程序时，可以将其能力声明为服务。我们消费的任何外部应用程序/服务或资源（例如数据库或消息代理）也应该声明为我们可以通过网络消费的服务。

### 服务间通信和组合

服务交互与其他系统之间是云原生应用开发的关键部分。这些交互使用各种通信模式和协议通过网络进行。这些交互可能涉及使用多个服务、创建组合、创建基于事件的消费者或生产者等。我们还必须构建某些功能——例如应用程序级安全性、弹性通信（断路器、带有退避和超时的重试逻辑）、路由、发布指标和可观察性工具的跟踪——作为服务间通信逻辑的一部分，尽管它们并不是业务逻辑的真正组成部分。

### 将功能公开为API

对于某些能力，服务的概念可以进一步扩展到*托管 API*的概念. 由于云原生应用程序的大部分业务能力都可以暴露给外部和内部各方，因此我们希望使其成为托管服务/API。这意味着您可以使用 API 网关和管理平面 （API 管理/控制平面）实现功能（您向消费者公开的 API），例如安全性、节流、缓存、版本控制、货币化（从公开的 API 中创造收入）、启用开发人员门户等.

该*API网关*充当您能力的前门和*开发人员门户*可以围绕您的 API 建设生态系统。API 管理应该针对服务的外部和内部消费进行。但是，API 管理并未内置于 Kubernetes 等容器编排平台中。因此，您需要明确使用 API 管理技术将您的微服务公开为托管 API.

### 自动化开发、发布和部署

正如我们所指出的 在本章前面，将开发、发布和交付过程中尽可能多的步骤自动化是构建云原生应用程序的重要部分构建云原生应用程序的各个阶段（例如测试、代码推送、构建、集成测试、发布、部署和运行）应该通过使用持续集成、持续部署、和持续交付技术和框架实现自动化。

### 在动态环境中运行

在运行云原生应用程序的阶段，您可以设置要在执行环境中部署和执行的应用程序，作为上一阶段的一部分。这里的关键思想是确保您的应用程序独立于执行环境，并且可以在各种执行环境（开发、测试、生产等）中执行，而无需对应用程序代码进行任何更改。由于您使用容器作为交付模型，因此执行运行时通常包含一个容器编排系统。执行环境可以是本地环境；公共、混合或私有云；甚至多个云环境。

### 动态管理的控制平面

它允许您控制应用程序正在运行的动态环境的行为。该控制平面是 DevOps 和在运行时环境中运行应用程序的开发人员之间的主要交互点。通常，此类云控制平面由 Web 界面和代表性状态传输组成 (REST) 或远程过程调用(RPC) API。大多数云提供商都提供此类控制平面作为其云服务产品的一部分。

### 可观察性和监控

一旦部署应用程序后，构建云原生应用程序的下一阶段是观察它们的运行时行为。在软件应用程序的上下文中，*可观察性*是指无需部署任何新代码即可理解和解释系统状态的能力。这对于故障排除、记录业务交易、识别异常、识别业务模式、生成洞察等至关重要。

在可观察性和监控阶段，需要在云原生应用程序中启用关键的可观察性方面。其中包括日志记录、指标、跟踪和服务可视化。工具是为这些方面中的每一个明确构建的，大多数云提供商都将这些功能作为托管云服务提供开箱即用。从应用程序代码级别，可能必须在不更改应用程序代码的情况下启用代理或客户端库。

## 用于构建云原生应用程序的设计模式

云原生设计模式到底是什么, 到底有哪些模式, 解决什么问题这个接下来我们要讨论的内容.简单介绍模式如下:

### 沟通模式

云原生应用程序由一组分布在网络中的微服务组成。云原生*通信模式*都是关于这些服务如何相互通信以及与外部实体通信。

即使是构建一个非常简单的业务用例，您的应用程序也需要使用外部服务（例如，可以是另一个服务、数据库或消息代理）。因此，构建您的应用程序与这些外部服务之间的交互正成为构建云原生应用程序中最常见但最复杂的任务之一。

分布式计算世界的大多数传统服务间通信模式和技术都不能直接应用于云原生应用程序开发的上下文中。我们需要选择非常适合应用程序的云原生属性（例如，允许服务自主性和可扩展性的模式）以及业务用例（例如，一些可能需要交付保证，而另一些可能需要实时响应）。

云原生应用程序之间的服务间通信使用同步或异步通信模式实现。在*同步通信中*，我们使用请求/响应和 RPC 等模式。在*异步通信中*，我们使用诸如基于队列和发布者-订阅者 (pub-sub) 消息传递等模式。在大多数实际用例中，您需要同时使用这两个类别来构建服务交互。当涉及到通信模式时，服务接口定义和契约也起着至关重要的作用，因为它们是表达如何使用给定服务的标准方式。

除了服务到服务的交互之外，某些云原生应用程序可能必须与外部方（例如前端客户端或支持服务）进行通信。作为应用程序开发人员，您需要处理大量活动部件并与外部服务和系统进行大量交互。

### 连接和组合模式

你拥有的微服务越多，服务间的通信就越多。因此，在设计云原生应用时，需要引入某些能力和抽象，以降低服务间通信的复杂性。这就是*连接和组合模式*出现的地方。

#### 连通性

在上下文中在服务间通信中，*连通性*是指在服务之间建立可靠、安全、可发现、可管理、可观察的通信通道。例如，当给定服务调用另一个服务时，您需要应用某些可靠性模式，例如重试或建立安全通信通道。它们不是应用程序业务逻辑的一部分，但对于构建强大的连接至关重要。

#### 组合模式

建造时在云原生应用程序中，通过管道或集成一个或多个其他服务或系统来创建服务是很常见的。这些称为*组合*（也称为*组合服务*和*集成服务*）。

在SOA通常是通过ESB进行组合。在这个架构中使用了大量的组合模式，它们通常被称为*企业集成模式*（*EIP*）。

但是，在云原生时代，我们不使用中央组合层。所有这些任务都需要作为我们开发的服务的一部分来完成。

### 数据管理模式

云原生应用程序需要处理一些数据管理。您的应用程序通常由充当持久存储的数据库支持，以存储应用程序状态或构建服务所需的业务数据。正如您之前了解到的，云原生应用程序本质上是分布式的。因此，数据管理也是以完全分散的方式进行的。

在常规单体应用程序，我们曾经有一个中央共享数据存储，许多应用程序与之交互。对于云原生应用程序，我们让给定的微服务拥有自己的数据存储，外部各方只能通过该服务接口与其交互。使用这种隔离的数据管理方法，在微服务之间访问、共享和同步数据变得具有挑战性。这就是为什么了解云原生数据管理模式对于云原生应用程序开发至关重要。

### 事件驱动架构模式

当我们讨论云原生通信模式，我们讨论了异步消息传递作为服务间通信技术。这是事件驱动的云原生应用程序的基础。数十年来，*事件驱动架构*( *EDA* ) 已广泛用于应用程序开发。在云原生应用程序的上下文中，EDA 起着至关重要的作用，因为它是启用自主微服务的好方法。与查询或 RPC 等同步通信技术不同，EDA 实现了更加解耦的微服务交互。

### 流处理模式

在 EDA 中，我们处理一次只有一个事件。换句话说，微服务的业务逻辑是为了一次处理一个事件而编写的。后续事件之间没有相关性。一个*流*另一方面，是随着时间的推移可用的一系列事件或数据元素。这些事件由应用程序以有状态的方式处理。

这种微服务的实现和部署架构与事件驱动的微服务发生了巨大的变化，因为它必须处理状态、进行高效的数据处理、管理各种扩展和并发语义等。

### API 管理和消费模式

在大多数中等或云原生架构的大规模用例，您必须将应用程序的某些业务能力暴露给应用程序范围之外的外部或内部方。您需要公开诸如托管服务或 API 之类的功能. 这使您可以更好地控制外部各方如何使用这些功能，并使外部各方能够轻松发现这些 API 并提供反馈。

公开这些功能通常是通过使用单独的 API 网关层来完成的，该层充当您公开的所有 API 的前门。API 网关还包括围绕公开的 API 构建的管理平面和开发人员门户。

## 云原生应用参考架构

参考架构包含多个使用不同通信模式进行通信的微服务。每个服务都可以使用自己的数据或持久存储，并且还有一个共享的或私有的事件代理基础设施。微服务之间的交互代表了我们可以实现的所有通信模式。每个通信链路都可以通过使用与可靠性、安全性、路由等相关的连接模式来实现。

![image-20220105163500116](PatternForCloudNative.assets/image-20220105163500116.png)

# 通信模式

随着微服务的激增和不断增长的业务需求，在云原生应用程序中在微服务之间建立强大的通信是云原生架构中最困难的挑战之一。

## 同步消息模式

### 请求-响应模式

基本最常见的同行模式, 应用最多的为Restful. 具体内容不在本文详述.

### RPC模式

它使分布式应用程序能够调用远程应用程序的过程——就像进行本地过程调用一样。一个给定的微服务可以将特定的业务逻辑构建为一个函数，并使其可供驻留在单独进程中的消费者进行远程调用。在Kubernetes也大量应用RPC调用, 先比较Restful而言, 具有更高性能, 更低资源. 但是同样具有了更强的耦合性.

简单过程介绍如下图:

<img src="PatternForCloudNative.assets/image-20220105164057543.png" alt="image-20220105164057543" style="zoom:80%;" />

现在也有多数组件提供gRPC的跨语言支持, 进一步减少了耦合性. 具体如何选择, 需要根据业务的要求例如: 数据量, 语言平台, 变更频率, 时延要求, 指标要求等.

## 异步消息传递模式

在云原生项目中, 通常提供集中式的消息组件来构建基本的消息系统, 而应用通过对消息平台的访问达到传递消息的目的. 大约有以下几种消息使用模式:

### 单接收器模式

在*单接收器模式中*，给定的微服务将消息准确地传递给一个目标微服务，或者传递给使用消息传递基础设施（如消息代理）的系统。此处发送的消息通常被视为*命令，*因为该模式可确保将消息传递给应该处理它们并执行操作的单个使用者。

典型应用示例:

![image-20220105164550112](PatternForCloudNative.assets/image-20220105164550112.png)

有许多不同的消息组件均能够满足要求, 具体选择哪个需要根据业务类型, 数据量, 技术背景等做选择.

### 多接收器模式

基于单一消费者的异步当您有一个消费者来使用您发布到消息代理的消息时，消息传递工作。如果您必须向对特定事件感兴趣的多个消费者发送相同的消息怎么办？

![image-20220105164735817](PatternForCloudNative.assets/image-20220105164735817.png)

### 异步请求-回复模式

请求回复模式通常是单接收模式的变体, 通过两段的发送和监听达到请求回复的要求, 如下图:

![image-20220105164917645](PatternForCloudNative.assets/image-20220105164917645.png)

### 服务定义模式

建造时云原生应用程序之间的通信，需要考虑的最重要的方面之一是*服务定义——*你如何定义你的微服务接口给它的消费者。

#### 同步通信中的服务定义

当我们构建同步服务时，我们可以将服务定义发布到称为*服务注册*中心的中心位置. 这是其他微服务和开发人员可以与之交互的元数据存储库。在定义服务接口时，您可以从多种技术中进行选择，具体取决于您用于同步通信的通信协议（例如，RESTful、gRPC 等）。

<img src="PatternForCloudNative.assets/image-20220105165151673.png" alt="image-20220105165151673" style="zoom:67%;" />

#### 异步通信中的服务定义

在异步通信，生产者和消费者之间交换的消息包含使用*模式*序列化或反序列化的结构化数据定义和验证各方之间交换的数据。由于通信是通过消息代理或事件总线异步发生的，因此生成和使用消息的微服务应该使用通用模式。类似于同步消息场景中的服务定义，生产者和消费者微服务必须使用中央元数据 注册表来存储模式。

<img src="PatternForCloudNative.assets/image-20220105165246001.png" alt="image-20220105165246001" style="zoom:80%;" />

实现同步消息传递模式技术常见的有:

RESTFul, GraphQL, WebSocket, gRPC, 

异步消息常见的有:

AMQP, Kafka, RabitMQ, RockatMQ, ActiveMQ, MQ, NATS等

# 连接和组合模式

## 服务连接模式

该*服务连接模式*是一种高级复合模式，可用于构建云原生应用程序。该模式解释了如何通过连接微服务和现有系统来形成云原生应用程序，以及这些服务如何与应用程序的使用者交互

![image-20220105165822443](PatternForCloudNative.assets/image-20220105165822443.png)

## 服务抽象模式

什么时候云原生应用程序中的微服务需要与另一个微服务或外部系统进行交互，最好使用一种抽象来隐藏底层实现、位置和部署结构的细节。这是*服务抽象模式*背后的关键思想。这种模式使用一个服务来抽象一个或多个底层服务。

<img src="PatternForCloudNative.assets/image-20220105165929244.png" alt="image-20220105165929244" style="zoom:50%;" />

典型的用例, 在K8S中, 使用Service对后端Pod进行抽象, 而不是直接访问Pod的IP.

再更近一步, K8S对所有的服务再进行一次抽象, 通过外部的负载均衡器完成对所有Pod的负载均衡, 如下图:

![image-20220105170126440](PatternForCloudNative.assets/image-20220105170126440.png)